/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type ULONG = ::std::os::raw::c_ulong;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type PUCHAR = *mut UCHAR;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type PINT = *mut ::std::os::raw::c_int;
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type PUINT = *mut ::std::os::raw::c_uint;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type SHORT = ::std::os::raw::c_short;
pub type HANDLE = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HWND__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OVERLAPPED {
    pub Internal: ULONG_PTR,
    pub InternalHigh: ULONG_PTR,
    pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1,
    pub hEvent: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OVERLAPPED__bindgen_ty_1 {
    pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1__bindgen_ty_1,
    pub Pointer: PVOID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OVERLAPPED__bindgen_ty_1__bindgen_ty_1 {
    pub Offset: DWORD,
    pub OffsetHigh: DWORD,
}
impl Default for _OVERLAPPED__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _OVERLAPPED {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LPOVERLAPPED = *mut _OVERLAPPED;
pub const _USBD_PIPE_TYPE_UsbdPipeTypeControl: _USBD_PIPE_TYPE = 0;
pub const _USBD_PIPE_TYPE_UsbdPipeTypeIsochronous: _USBD_PIPE_TYPE = 1;
pub const _USBD_PIPE_TYPE_UsbdPipeTypeBulk: _USBD_PIPE_TYPE = 2;
pub const _USBD_PIPE_TYPE_UsbdPipeTypeInterrupt: _USBD_PIPE_TYPE = 3;
pub type _USBD_PIPE_TYPE = ::std::os::raw::c_int;
pub use self::_USBD_PIPE_TYPE as USBD_PIPE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WINUSB_PIPE_INFORMATION {
    pub PipeType: USBD_PIPE_TYPE,
    pub PipeId: UCHAR,
    pub MaximumPacketSize: USHORT,
    pub Interval: UCHAR,
}
impl Default for _WINUSB_PIPE_INFORMATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type WINUSB_PIPE_INFORMATION = _WINUSB_PIPE_INFORMATION;
pub type PWINUSB_PIPE_INFORMATION = *mut WINUSB_PIPE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WINUSB_PIPE_INFORMATION_EX {
    pub PipeType: USBD_PIPE_TYPE,
    pub PipeId: UCHAR,
    pub MaximumPacketSize: USHORT,
    pub Interval: UCHAR,
    pub MaximumBytesPerInterval: ULONG,
}
impl Default for _WINUSB_PIPE_INFORMATION_EX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type WINUSB_PIPE_INFORMATION_EX = _WINUSB_PIPE_INFORMATION_EX;
pub type PWINUSB_PIPE_INFORMATION_EX = *mut WINUSB_PIPE_INFORMATION_EX;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WINUSB_SETUP_PACKET {
    pub RequestType: UCHAR,
    pub Request: UCHAR,
    pub Value: USHORT,
    pub Index: USHORT,
    pub Length: USHORT,
}
pub type WINUSB_SETUP_PACKET = _WINUSB_SETUP_PACKET;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KISO_PACKET {
    pub Offset: UINT,
    pub Length: USHORT,
    pub Status: USHORT,
}
pub type KISO_PACKET = _KISO_PACKET;
pub type PKISO_PACKET = *mut KISO_PACKET;
pub const _KISO_FLAG_KISO_FLAG_NONE: _KISO_FLAG = 0;
pub const _KISO_FLAG_KISO_FLAG_SET_START_FRAME: _KISO_FLAG = 1;
pub type _KISO_FLAG = ::std::os::raw::c_int;
pub use self::_KISO_FLAG as KISO_FLAG;
#[repr(C, packed)]
pub struct _KISO_CONTEXT {
    pub Flags: KISO_FLAG,
    pub StartFrame: UINT,
    pub ErrorCount: SHORT,
    pub NumberOfPackets: SHORT,
    pub UrbHdrStatus: UINT,
    pub IsoPackets: __IncompleteArrayField<KISO_PACKET>,
}
impl Default for _KISO_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KISO_CONTEXT = _KISO_CONTEXT;
pub type PKISO_CONTEXT = *mut KISO_CONTEXT;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KISOCH_PACKET_INFORMATION {
    pub PacketsPerFrame: UINT,
    pub PollingPeriodMicroseconds: UINT,
    pub BytesPerMillisecond: UINT,
}
pub type KISOCH_PACKET_INFORMATION = _KISOCH_PACKET_INFORMATION;
pub type PKISOCH_PACKET_INFORMATION = *mut KISOCH_PACKET_INFORMATION;
pub type KPROC = ::std::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type KLIB_USER_CONTEXT = INT_PTR;
pub type KLIB_HANDLE = *mut ::std::os::raw::c_void;
pub type KUSB_HANDLE = KLIB_HANDLE;
pub type KLST_HANDLE = KLIB_HANDLE;
pub type KHOT_HANDLE = KLIB_HANDLE;
pub type KOVL_HANDLE = KLIB_HANDLE;
pub type KOVL_POOL_HANDLE = KLIB_HANDLE;
pub type KSTM_HANDLE = KLIB_HANDLE;
pub type KISOCH_HANDLE = KLIB_HANDLE;
pub const _KLIB_HANDLE_TYPE_KLIB_HANDLE_TYPE_HOTK: _KLIB_HANDLE_TYPE = 0;
pub const _KLIB_HANDLE_TYPE_KLIB_HANDLE_TYPE_USBK: _KLIB_HANDLE_TYPE = 1;
pub const _KLIB_HANDLE_TYPE_KLIB_HANDLE_TYPE_USBSHAREDK: _KLIB_HANDLE_TYPE = 2;
pub const _KLIB_HANDLE_TYPE_KLIB_HANDLE_TYPE_LSTK: _KLIB_HANDLE_TYPE = 3;
pub const _KLIB_HANDLE_TYPE_KLIB_HANDLE_TYPE_LSTINFOK: _KLIB_HANDLE_TYPE = 4;
pub const _KLIB_HANDLE_TYPE_KLIB_HANDLE_TYPE_OVLK: _KLIB_HANDLE_TYPE = 5;
pub const _KLIB_HANDLE_TYPE_KLIB_HANDLE_TYPE_OVLPOOLK: _KLIB_HANDLE_TYPE = 6;
pub const _KLIB_HANDLE_TYPE_KLIB_HANDLE_TYPE_STMK: _KLIB_HANDLE_TYPE = 7;
pub const _KLIB_HANDLE_TYPE_KLIB_HANDLE_TYPE_ISOCHK: _KLIB_HANDLE_TYPE = 8;
pub const _KLIB_HANDLE_TYPE_KLIB_HANDLE_TYPE_COUNT: _KLIB_HANDLE_TYPE = 9;
pub type _KLIB_HANDLE_TYPE = ::std::os::raw::c_int;
pub use self::_KLIB_HANDLE_TYPE as KLIB_HANDLE_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KLIB_VERSION {
    pub Major: INT,
    pub Minor: INT,
    pub Micro: INT,
    pub Nano: INT,
}
pub type KLIB_VERSION = _KLIB_VERSION;
pub type PKLIB_VERSION = *mut KLIB_VERSION;
pub const _KLST_SYNC_FLAG_KLST_SYNC_FLAG_NONE: _KLST_SYNC_FLAG = 0;
pub const _KLST_SYNC_FLAG_KLST_SYNC_FLAG_UNCHANGED: _KLST_SYNC_FLAG = 1;
pub const _KLST_SYNC_FLAG_KLST_SYNC_FLAG_ADDED: _KLST_SYNC_FLAG = 2;
pub const _KLST_SYNC_FLAG_KLST_SYNC_FLAG_REMOVED: _KLST_SYNC_FLAG = 4;
pub const _KLST_SYNC_FLAG_KLST_SYNC_FLAG_CONNECT_CHANGE: _KLST_SYNC_FLAG = 8;
pub const _KLST_SYNC_FLAG_KLST_SYNC_FLAG_MASK: _KLST_SYNC_FLAG = 15;
pub type _KLST_SYNC_FLAG = ::std::os::raw::c_int;
pub use self::_KLST_SYNC_FLAG as KLST_SYNC_FLAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KLST_DEV_COMMON_INFO {
    pub Vid: INT,
    pub Pid: INT,
    pub MI: INT,
    pub InstanceID: [CHAR; 256usize],
}
impl Default for _KLST_DEV_COMMON_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KLST_DEV_COMMON_INFO = _KLST_DEV_COMMON_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KLST_DEVINFO {
    pub Common: KLST_DEV_COMMON_INFO,
    pub DriverID: INT,
    pub DeviceInterfaceGUID: [CHAR; 256usize],
    pub DeviceID: [CHAR; 256usize],
    pub ClassGUID: [CHAR; 256usize],
    pub Mfg: [CHAR; 256usize],
    pub DeviceDesc: [CHAR; 256usize],
    pub Service: [CHAR; 256usize],
    pub SymbolicLink: [CHAR; 256usize],
    pub DevicePath: [CHAR; 256usize],
    pub LUsb0FilterIndex: INT,
    pub Connected: BOOL,
    pub SyncFlags: KLST_SYNC_FLAG,
    pub BusNumber: INT,
    pub DeviceAddress: INT,
    pub SerialNumber: [CHAR; 256usize],
}
impl Default for _KLST_DEVINFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KLST_DEVINFO = _KLST_DEVINFO;
pub type KLST_DEVINFO_HANDLE = *mut KLST_DEVINFO;
pub const _KLST_FLAG_KLST_FLAG_NONE: _KLST_FLAG = 0;
pub const _KLST_FLAG_KLST_FLAG_INCLUDE_RAWGUID: _KLST_FLAG = 1;
pub const _KLST_FLAG_KLST_FLAG_INCLUDE_DISCONNECT: _KLST_FLAG = 2;
pub type _KLST_FLAG = ::std::os::raw::c_int;
pub use self::_KLST_FLAG as KLST_FLAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KLST_PATTERN_MATCH {
    pub DeviceID: [CHAR; 256usize],
    pub DeviceInterfaceGUID: [CHAR; 256usize],
    pub ClassGUID: [CHAR; 256usize],
    pub z_F_i_x_e_d: [UCHAR; 256usize],
}
impl Default for _KLST_PATTERN_MATCH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KLST_PATTERN_MATCH = _KLST_PATTERN_MATCH;
pub type PKLST_PATTERN_MATCH = *mut KLST_PATTERN_MATCH;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _USB_ENDPOINT_DESCRIPTOR {
    pub bLength: UCHAR,
    pub bDescriptorType: UCHAR,
    pub bEndpointAddress: UCHAR,
    pub bmAttributes: UCHAR,
    pub wMaxPacketSize: USHORT,
    pub bInterval: UCHAR,
}
pub type USB_ENDPOINT_DESCRIPTOR = _USB_ENDPOINT_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR {
    pub bLength: UCHAR,
    pub bDescriptorType: UCHAR,
    pub bMaxBurst: UCHAR,
    pub bmAttributes: _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR__bindgen_ty_1,
    pub wBytesPerInterval: USHORT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR__bindgen_ty_1 {
    pub AsUchar: UCHAR,
    pub Bulk: _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Isochronous: _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn MaxStreams(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_MaxStreams(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MaxStreams: UCHAR,
        Reserved1: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let MaxStreams: u8 = unsafe { ::std::mem::transmute(MaxStreams) };
            MaxStreams as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Reserved1: u8 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn Mult(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Mult(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn SspCompanion(&self) -> UCHAR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SspCompanion(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Mult: UCHAR,
        Reserved2: UCHAR,
        SspCompanion: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Mult: u8 = unsafe { ::std::mem::transmute(Mult) };
            Mult as u64
        });
        __bindgen_bitfield_unit.set(2usize, 5u8, {
            let Reserved2: u8 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SspCompanion: u8 = unsafe { ::std::mem::transmute(SspCompanion) };
            SspCompanion as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PUSB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR =
    *mut _USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _USB_INTERFACE_DESCRIPTOR {
    pub bLength: UCHAR,
    pub bDescriptorType: UCHAR,
    pub bInterfaceNumber: UCHAR,
    pub bAlternateSetting: UCHAR,
    pub bNumEndpoints: UCHAR,
    pub bInterfaceClass: UCHAR,
    pub bInterfaceSubClass: UCHAR,
    pub bInterfaceProtocol: UCHAR,
    pub iInterface: UCHAR,
}
pub type USB_INTERFACE_DESCRIPTOR = _USB_INTERFACE_DESCRIPTOR;
pub type PUSB_INTERFACE_DESCRIPTOR = *mut USB_INTERFACE_DESCRIPTOR;
pub const _KUSB_PROPERTY_KUSB_PROPERTY_DEVICE_FILE_HANDLE: _KUSB_PROPERTY = 0;
pub const _KUSB_PROPERTY_KUSB_PROPERTY_COUNT: _KUSB_PROPERTY = 1;
pub type _KUSB_PROPERTY = ::std::os::raw::c_int;
pub use self::_KUSB_PROPERTY as KUSB_PROPERTY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSB_DRIVER_API_INFO {
    pub DriverID: INT,
    pub FunctionCount: INT,
}
pub type KUSB_DRIVER_API_INFO = _KUSB_DRIVER_API_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KUSB_DRIVER_API {
    pub Info: KUSB_DRIVER_API_INFO,
    pub Init: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut KUSB_HANDLE, arg2: KLST_DEVINFO_HANDLE) -> BOOL,
    >,
    pub Free: ::std::option::Option<unsafe extern "C" fn(arg1: KUSB_HANDLE) -> BOOL>,
    pub ClaimInterface: ::std::option::Option<
        unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR, arg3: BOOL) -> BOOL,
    >,
    pub ReleaseInterface: ::std::option::Option<
        unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR, arg3: BOOL) -> BOOL,
    >,
    pub SetAltInterface: ::std::option::Option<
        unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR, arg3: BOOL, arg4: UCHAR) -> BOOL,
    >,
    pub GetAltInterface: ::std::option::Option<
        unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR, arg3: BOOL, arg4: PUCHAR) -> BOOL,
    >,
    pub GetDescriptor: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: UCHAR,
            arg4: USHORT,
            arg5: PUCHAR,
            arg6: UINT,
            arg7: PUINT,
        ) -> BOOL,
    >,
    pub ControlTransfer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: WINUSB_SETUP_PACKET,
            arg3: PUCHAR,
            arg4: UINT,
            arg5: PUINT,
            arg6: LPOVERLAPPED,
        ) -> BOOL,
    >,
    pub SetPowerPolicy: ::std::option::Option<
        unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UINT, arg3: UINT, arg4: PVOID) -> BOOL,
    >,
    pub GetPowerPolicy: ::std::option::Option<
        unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UINT, arg3: PUINT, arg4: PVOID) -> BOOL,
    >,
    pub SetConfiguration:
        ::std::option::Option<unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR) -> BOOL>,
    pub GetConfiguration:
        ::std::option::Option<unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: PUCHAR) -> BOOL>,
    pub ResetDevice: ::std::option::Option<unsafe extern "C" fn(arg1: KUSB_HANDLE) -> BOOL>,
    pub Initialize:
        ::std::option::Option<unsafe extern "C" fn(arg1: HANDLE, arg2: *mut KUSB_HANDLE) -> BOOL>,
    pub SelectInterface: ::std::option::Option<
        unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR, arg3: BOOL) -> BOOL,
    >,
    pub GetAssociatedInterface: ::std::option::Option<
        unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR, arg3: *mut KUSB_HANDLE) -> BOOL,
    >,
    pub Clone: ::std::option::Option<
        unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: *mut KUSB_HANDLE) -> BOOL,
    >,
    pub QueryInterfaceSettings: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: PUSB_INTERFACE_DESCRIPTOR,
        ) -> BOOL,
    >,
    pub QueryDeviceInformation: ::std::option::Option<
        unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UINT, arg3: PUINT, arg4: PUCHAR) -> BOOL,
    >,
    pub SetCurrentAlternateSetting:
        ::std::option::Option<unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR) -> BOOL>,
    pub GetCurrentAlternateSetting:
        ::std::option::Option<unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: PUCHAR) -> BOOL>,
    pub QueryPipe: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: UCHAR,
            arg4: PWINUSB_PIPE_INFORMATION,
        ) -> BOOL,
    >,
    pub SetPipePolicy: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: UINT,
            arg4: UINT,
            arg5: PVOID,
        ) -> BOOL,
    >,
    pub GetPipePolicy: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: UINT,
            arg4: PUINT,
            arg5: PVOID,
        ) -> BOOL,
    >,
    pub ReadPipe: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: PUCHAR,
            arg4: UINT,
            arg5: PUINT,
            arg6: LPOVERLAPPED,
        ) -> BOOL,
    >,
    pub WritePipe: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: PUCHAR,
            arg4: UINT,
            arg5: PUINT,
            arg6: LPOVERLAPPED,
        ) -> BOOL,
    >,
    pub ResetPipe:
        ::std::option::Option<unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR) -> BOOL>,
    pub AbortPipe:
        ::std::option::Option<unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR) -> BOOL>,
    pub FlushPipe:
        ::std::option::Option<unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: UCHAR) -> BOOL>,
    pub IsoReadPipe: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: PUCHAR,
            arg4: UINT,
            arg5: LPOVERLAPPED,
            arg6: PKISO_CONTEXT,
        ) -> BOOL,
    >,
    pub IsoWritePipe: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: PUCHAR,
            arg4: UINT,
            arg5: LPOVERLAPPED,
            arg6: PKISO_CONTEXT,
        ) -> BOOL,
    >,
    pub GetCurrentFrameNumber:
        ::std::option::Option<unsafe extern "C" fn(arg1: KUSB_HANDLE, arg2: PUINT) -> BOOL>,
    pub GetOverlappedResult: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: LPOVERLAPPED,
            arg3: PUINT,
            arg4: BOOL,
        ) -> BOOL,
    >,
    pub GetProperty: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: KUSB_PROPERTY,
            arg3: PUINT,
            arg4: PVOID,
        ) -> BOOL,
    >,
    pub IsochReadPipe: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KISOCH_HANDLE,
            arg2: UINT,
            arg3: PUINT,
            arg4: UINT,
            arg5: LPOVERLAPPED,
        ) -> BOOL,
    >,
    pub IsochWritePipe: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KISOCH_HANDLE,
            arg2: UINT,
            arg3: PUINT,
            arg4: UINT,
            arg5: LPOVERLAPPED,
        ) -> BOOL,
    >,
    pub QueryPipeEx: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: UCHAR,
            arg4: PWINUSB_PIPE_INFORMATION_EX,
        ) -> BOOL,
    >,
    pub GetSuperSpeedPipeCompanionDescriptor: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: KUSB_HANDLE,
            arg2: UCHAR,
            arg3: UCHAR,
            arg4: PUSB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR,
        ) -> BOOL,
    >,
    pub z_F_i_x_e_d: [UCHAR; 160usize],
    pub z_FuncSupported: [UCHAR; 40usize],
}
impl Default for _KUSB_DRIVER_API {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KUSB_DRIVER_API = _KUSB_DRIVER_API;
pub type PKUSB_DRIVER_API = *mut KUSB_DRIVER_API;
pub const _KHOT_FLAG_KHOT_FLAG_NONE: _KHOT_FLAG = 0;
pub const _KHOT_FLAG_KHOT_FLAG_PLUG_ALL_ON_INIT: _KHOT_FLAG = 1;
pub const _KHOT_FLAG_KHOT_FLAG_PASS_DUPE_INSTANCE: _KHOT_FLAG = 2;
pub const _KHOT_FLAG_KHOT_FLAG_POST_USER_MESSAGE: _KHOT_FLAG = 4;
pub type _KHOT_FLAG = ::std::os::raw::c_int;
pub use self::_KHOT_FLAG as KHOT_FLAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KHOT_PARAMS {
    pub UserHwnd: HWND,
    pub UserMessage: UINT,
    pub Flags: KHOT_FLAG,
    pub PatternMatch: KLST_PATTERN_MATCH,
    pub OnHotPlug: ::std::option::Option<
        unsafe extern "C" fn(arg1: KHOT_HANDLE, arg2: KLST_DEVINFO_HANDLE, arg3: KLST_SYNC_FLAG),
    >,
    pub OnPowerBroadcast: ::std::option::Option<
        unsafe extern "C" fn(arg1: KHOT_HANDLE, arg2: KLST_DEVINFO_HANDLE, arg3: UINT),
    >,
    pub z_F_i_x_e_d: [UCHAR; 992usize],
}
impl Default for _KHOT_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KHOT_PARAMS = _KHOT_PARAMS;
pub type PKHOT_PARAMS = *mut KHOT_PARAMS;
pub const _KOVL_WAIT_FLAG_KOVL_WAIT_FLAG_NONE: _KOVL_WAIT_FLAG = 0;
pub const _KOVL_WAIT_FLAG_KOVL_WAIT_FLAG_RELEASE_ON_SUCCESS: _KOVL_WAIT_FLAG = 1;
pub const _KOVL_WAIT_FLAG_KOVL_WAIT_FLAG_RELEASE_ON_FAIL: _KOVL_WAIT_FLAG = 2;
pub const _KOVL_WAIT_FLAG_KOVL_WAIT_FLAG_RELEASE_ON_SUCCESS_FAIL: _KOVL_WAIT_FLAG = 3;
pub const _KOVL_WAIT_FLAG_KOVL_WAIT_FLAG_CANCEL_ON_TIMEOUT: _KOVL_WAIT_FLAG = 4;
pub const _KOVL_WAIT_FLAG_KOVL_WAIT_FLAG_RELEASE_ON_TIMEOUT: _KOVL_WAIT_FLAG = 12;
pub const _KOVL_WAIT_FLAG_KOVL_WAIT_FLAG_RELEASE_ALWAYS: _KOVL_WAIT_FLAG = 15;
pub const _KOVL_WAIT_FLAG_KOVL_WAIT_FLAG_ALERTABLE: _KOVL_WAIT_FLAG = 16;
pub type _KOVL_WAIT_FLAG = ::std::os::raw::c_int;
pub use self::_KOVL_WAIT_FLAG as KOVL_WAIT_FLAG;
pub const _KOVL_POOL_FLAG_KOVL_POOL_FLAG_NONE: _KOVL_POOL_FLAG = 0;
pub type _KOVL_POOL_FLAG = ::std::os::raw::c_int;
pub use self::_KOVL_POOL_FLAG as KOVL_POOL_FLAG;
pub const _KSTM_FLAG_KSTM_FLAG_NONE: _KSTM_FLAG = 0;
pub const _KSTM_FLAG_KSTM_FLAG_NO_PARTIAL_XFERS: _KSTM_FLAG = 1048576;
pub const _KSTM_FLAG_KSTM_FLAG_USE_TIMEOUT: _KSTM_FLAG = -2147483648;
pub const _KSTM_FLAG_KSTM_FLAG_TIMEOUT_MASK: _KSTM_FLAG = 131071;
pub type _KSTM_FLAG = ::std::os::raw::c_int;
pub use self::_KSTM_FLAG as KSTM_FLAG;
pub const _KSTM_COMPLETE_RESULT_KSTM_COMPLETE_RESULT_VALID: _KSTM_COMPLETE_RESULT = 0;
pub const _KSTM_COMPLETE_RESULT_KSTM_COMPLETE_RESULT_INVALID: _KSTM_COMPLETE_RESULT = 1;
pub type _KSTM_COMPLETE_RESULT = ::std::os::raw::c_int;
pub use self::_KSTM_COMPLETE_RESULT as KSTM_COMPLETE_RESULT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSTM_XFER_CONTEXT {
    pub Buffer: PUCHAR,
    pub BufferSize: INT,
    pub TransferLength: INT,
    pub UserState: PVOID,
}
impl Default for _KSTM_XFER_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KSTM_XFER_CONTEXT = _KSTM_XFER_CONTEXT;
pub type PKSTM_XFER_CONTEXT = *mut KSTM_XFER_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSTM_INFO {
    pub UsbHandle: KUSB_HANDLE,
    pub PipeID: UCHAR,
    pub MaxPendingTransfers: INT,
    pub MaxTransferSize: INT,
    pub MaxPendingIO: INT,
    pub EndpointDescriptor: USB_ENDPOINT_DESCRIPTOR,
    pub DriverAPI: KUSB_DRIVER_API,
    pub DeviceHandle: HANDLE,
    pub StreamHandle: KSTM_HANDLE,
    pub UserState: PVOID,
}
impl Default for _KSTM_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KSTM_INFO = _KSTM_INFO;
pub type PKSTM_INFO = *mut KSTM_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KSTM_CALLBACK {
    pub Error: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: PKSTM_INFO,
            arg2: PKSTM_XFER_CONTEXT,
            arg3: INT,
            arg4: INT,
        ) -> INT,
    >,
    pub Submit: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: PKSTM_INFO,
            arg2: PKSTM_XFER_CONTEXT,
            arg3: INT,
            arg4: LPOVERLAPPED,
        ) -> INT,
    >,
    pub Complete: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: PKSTM_INFO,
            arg2: PKSTM_XFER_CONTEXT,
            arg3: INT,
            arg4: INT,
        ) -> INT,
    >,
    pub Started: ::std::option::Option<
        unsafe extern "C" fn(arg1: PKSTM_INFO, arg2: PKSTM_XFER_CONTEXT, arg3: INT) -> INT,
    >,
    pub Stopped: ::std::option::Option<
        unsafe extern "C" fn(arg1: PKSTM_INFO, arg2: PKSTM_XFER_CONTEXT, arg3: INT) -> INT,
    >,
    pub BeforeComplete: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: PKSTM_INFO,
            arg2: PKSTM_XFER_CONTEXT,
            arg3: INT,
            arg4: PINT,
        ) -> KSTM_COMPLETE_RESULT,
    >,
    pub z_F_i_x_e_d: [UCHAR; 16usize],
}
pub type KSTM_CALLBACK = _KSTM_CALLBACK;
pub type PKSTM_CALLBACK = *mut KSTM_CALLBACK;
extern "C" {
    pub fn LibK_GetVersion(Version: PKLIB_VERSION);
}
extern "C" {
    pub fn LibK_GetContext(Handle: KLIB_HANDLE, HandleType: KLIB_HANDLE_TYPE) -> KLIB_USER_CONTEXT;
}
extern "C" {
    pub fn LibK_SetContext(
        Handle: KLIB_HANDLE,
        HandleType: KLIB_HANDLE_TYPE,
        ContextValue: KLIB_USER_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn LibK_SetCleanupCallback(
        Handle: KLIB_HANDLE,
        HandleType: KLIB_HANDLE_TYPE,
        CleanupCB: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: KLIB_HANDLE,
                arg2: KLIB_HANDLE_TYPE,
                arg3: KLIB_USER_CONTEXT,
            ) -> INT,
        >,
    ) -> BOOL;
}
extern "C" {
    pub fn LibK_LoadDriverAPI(DriverAPI: PKUSB_DRIVER_API, DriverID: INT) -> BOOL;
}
extern "C" {
    pub fn LibK_IsFunctionSupported(DriverAPI: PKUSB_DRIVER_API, FunctionID: UINT) -> BOOL;
}
extern "C" {
    pub fn LibK_CopyDriverAPI(DriverAPI: PKUSB_DRIVER_API, UsbHandle: KUSB_HANDLE) -> BOOL;
}
extern "C" {
    pub fn LibK_GetProcAddress(ProcAddress: *mut KPROC, DriverID: INT, FunctionID: INT) -> BOOL;
}
extern "C" {
    pub fn LibK_SetDefaultContext(
        HandleType: KLIB_HANDLE_TYPE,
        ContextValue: KLIB_USER_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn LibK_GetDefaultContext(HandleType: KLIB_HANDLE_TYPE) -> KLIB_USER_CONTEXT;
}
extern "C" {
    pub fn LibK_Context_Init(Heap: HANDLE, Reserved: PVOID) -> BOOL;
}
extern "C" {
    pub fn LibK_Context_Free();
}
extern "C" {
    pub fn UsbK_Init(InterfaceHandle: *mut KUSB_HANDLE, DevInfo: KLST_DEVINFO_HANDLE) -> BOOL;
}
extern "C" {
    pub fn UsbK_Free(InterfaceHandle: KUSB_HANDLE) -> BOOL;
}
extern "C" {
    pub fn UsbK_ClaimInterface(
        InterfaceHandle: KUSB_HANDLE,
        NumberOrIndex: UCHAR,
        IsIndex: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_ReleaseInterface(
        InterfaceHandle: KUSB_HANDLE,
        NumberOrIndex: UCHAR,
        IsIndex: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_SetAltInterface(
        InterfaceHandle: KUSB_HANDLE,
        NumberOrIndex: UCHAR,
        IsIndex: BOOL,
        AltSettingNumber: UCHAR,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetAltInterface(
        InterfaceHandle: KUSB_HANDLE,
        NumberOrIndex: UCHAR,
        IsIndex: BOOL,
        AltSettingNumber: PUCHAR,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetDescriptor(
        InterfaceHandle: KUSB_HANDLE,
        DescriptorType: UCHAR,
        Index: UCHAR,
        LanguageID: USHORT,
        Buffer: PUCHAR,
        BufferLength: UINT,
        LengthTransferred: PUINT,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_ControlTransfer(
        InterfaceHandle: KUSB_HANDLE,
        SetupPacket: WINUSB_SETUP_PACKET,
        Buffer: PUCHAR,
        BufferLength: UINT,
        LengthTransferred: PUINT,
        Overlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_SetPowerPolicy(
        InterfaceHandle: KUSB_HANDLE,
        PolicyType: UINT,
        ValueLength: UINT,
        Value: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetPowerPolicy(
        InterfaceHandle: KUSB_HANDLE,
        PolicyType: UINT,
        ValueLength: PUINT,
        Value: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_SetConfiguration(InterfaceHandle: KUSB_HANDLE, ConfigurationNumber: UCHAR) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetConfiguration(InterfaceHandle: KUSB_HANDLE, ConfigurationNumber: PUCHAR)
        -> BOOL;
}
extern "C" {
    pub fn UsbK_ResetDevice(InterfaceHandle: KUSB_HANDLE) -> BOOL;
}
extern "C" {
    pub fn UsbK_Initialize(DeviceHandle: HANDLE, InterfaceHandle: *mut KUSB_HANDLE) -> BOOL;
}
extern "C" {
    pub fn UsbK_SelectInterface(
        InterfaceHandle: KUSB_HANDLE,
        NumberOrIndex: UCHAR,
        IsIndex: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetAssociatedInterface(
        InterfaceHandle: KUSB_HANDLE,
        AssociatedInterfaceIndex: UCHAR,
        AssociatedInterfaceHandle: *mut KUSB_HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_Clone(InterfaceHandle: KUSB_HANDLE, DstInterfaceHandle: *mut KUSB_HANDLE) -> BOOL;
}
extern "C" {
    pub fn UsbK_QueryInterfaceSettings(
        InterfaceHandle: KUSB_HANDLE,
        AltSettingIndex: UCHAR,
        UsbAltInterfaceDescriptor: PUSB_INTERFACE_DESCRIPTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_QueryDeviceInformation(
        InterfaceHandle: KUSB_HANDLE,
        InformationType: UINT,
        BufferLength: PUINT,
        Buffer: PUCHAR,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_SetCurrentAlternateSetting(
        InterfaceHandle: KUSB_HANDLE,
        AltSettingNumber: UCHAR,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetCurrentAlternateSetting(
        InterfaceHandle: KUSB_HANDLE,
        AltSettingNumber: PUCHAR,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_QueryPipe(
        InterfaceHandle: KUSB_HANDLE,
        AltSettingNumber: UCHAR,
        PipeIndex: UCHAR,
        PipeInformation: PWINUSB_PIPE_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_QueryPipeEx(
        InterfaceHandle: KUSB_HANDLE,
        AltSettingNumber: UCHAR,
        PipeIndex: UCHAR,
        PipeInformationEx: PWINUSB_PIPE_INFORMATION_EX,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetSuperSpeedPipeCompanionDescriptor(
        InterfaceHandle: KUSB_HANDLE,
        AltSettingNumber: UCHAR,
        PipeIndex: UCHAR,
        PipeCompanionDescriptor: PUSB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_SetPipePolicy(
        InterfaceHandle: KUSB_HANDLE,
        PipeID: UCHAR,
        PolicyType: UINT,
        ValueLength: UINT,
        Value: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetPipePolicy(
        InterfaceHandle: KUSB_HANDLE,
        PipeID: UCHAR,
        PolicyType: UINT,
        ValueLength: PUINT,
        Value: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_ReadPipe(
        InterfaceHandle: KUSB_HANDLE,
        PipeID: UCHAR,
        Buffer: PUCHAR,
        BufferLength: UINT,
        LengthTransferred: PUINT,
        Overlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_WritePipe(
        InterfaceHandle: KUSB_HANDLE,
        PipeID: UCHAR,
        Buffer: PUCHAR,
        BufferLength: UINT,
        LengthTransferred: PUINT,
        Overlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_ResetPipe(InterfaceHandle: KUSB_HANDLE, PipeID: UCHAR) -> BOOL;
}
extern "C" {
    pub fn UsbK_AbortPipe(InterfaceHandle: KUSB_HANDLE, PipeID: UCHAR) -> BOOL;
}
extern "C" {
    pub fn UsbK_FlushPipe(InterfaceHandle: KUSB_HANDLE, PipeID: UCHAR) -> BOOL;
}
extern "C" {
    pub fn UsbK_IsoReadPipe(
        InterfaceHandle: KUSB_HANDLE,
        PipeID: UCHAR,
        Buffer: PUCHAR,
        BufferLength: UINT,
        Overlapped: LPOVERLAPPED,
        IsoContext: PKISO_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_IsoWritePipe(
        InterfaceHandle: KUSB_HANDLE,
        PipeID: UCHAR,
        Buffer: PUCHAR,
        BufferLength: UINT,
        Overlapped: LPOVERLAPPED,
        IsoContext: PKISO_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetCurrentFrameNumber(InterfaceHandle: KUSB_HANDLE, FrameNumber: PUINT) -> BOOL;
}
extern "C" {
    pub fn UsbK_IsochReadPipe(
        IsochHandle: KISOCH_HANDLE,
        DataLength: UINT,
        FrameNumber: PUINT,
        NumberOfPackets: UINT,
        Overlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_IsochWritePipe(
        IsochHandle: KISOCH_HANDLE,
        DataLength: UINT,
        FrameNumber: PUINT,
        NumberOfPackets: UINT,
        Overlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetOverlappedResult(
        InterfaceHandle: KUSB_HANDLE,
        Overlapped: LPOVERLAPPED,
        lpNumberOfBytesTransferred: PUINT,
        bWait: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn UsbK_GetProperty(
        InterfaceHandle: KUSB_HANDLE,
        PropertyType: KUSB_PROPERTY,
        PropertySize: PUINT,
        Value: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn LstK_Init(DeviceList: *mut KLST_HANDLE, Flags: KLST_FLAG) -> BOOL;
}
extern "C" {
    pub fn LstK_InitEx(
        DeviceList: *mut KLST_HANDLE,
        Flags: KLST_FLAG,
        PatternMatch: PKLST_PATTERN_MATCH,
    ) -> BOOL;
}
extern "C" {
    pub fn LstK_Free(DeviceList: KLST_HANDLE) -> BOOL;
}
extern "C" {
    pub fn LstK_Enumerate(
        DeviceList: KLST_HANDLE,
        EnumDevListCB: ::std::option::Option<
            unsafe extern "C" fn(arg1: KLST_HANDLE, arg2: KLST_DEVINFO_HANDLE, arg3: PVOID) -> BOOL,
        >,
        Context: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn LstK_Current(DeviceList: KLST_HANDLE, DeviceInfo: *mut KLST_DEVINFO_HANDLE) -> BOOL;
}
extern "C" {
    pub fn LstK_MoveNext(DeviceList: KLST_HANDLE, DeviceInfo: *mut KLST_DEVINFO_HANDLE) -> BOOL;
}
extern "C" {
    pub fn LstK_MoveReset(DeviceList: KLST_HANDLE);
}
extern "C" {
    pub fn LstK_FindByVidPid(
        DeviceList: KLST_HANDLE,
        Vid: INT,
        Pid: INT,
        DeviceInfo: *mut KLST_DEVINFO_HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn LstK_Count(DeviceList: KLST_HANDLE, Count: PUINT) -> BOOL;
}
extern "C" {
    pub fn HotK_Init(Handle: *mut KHOT_HANDLE, InitParams: PKHOT_PARAMS) -> BOOL;
}
extern "C" {
    pub fn HotK_Free(Handle: KHOT_HANDLE) -> BOOL;
}
extern "C" {
    pub fn HotK_FreeAll();
}
extern "C" {
    pub fn OvlK_Acquire(OverlappedK: *mut KOVL_HANDLE, PoolHandle: KOVL_POOL_HANDLE) -> BOOL;
}
extern "C" {
    pub fn OvlK_Release(OverlappedK: KOVL_HANDLE) -> BOOL;
}
extern "C" {
    pub fn OvlK_Init(
        PoolHandle: *mut KOVL_POOL_HANDLE,
        UsbHandle: KUSB_HANDLE,
        MaxOverlappedCount: INT,
        Flags: KOVL_POOL_FLAG,
    ) -> BOOL;
}
extern "C" {
    pub fn OvlK_Free(PoolHandle: KOVL_POOL_HANDLE) -> BOOL;
}
extern "C" {
    pub fn OvlK_GetEventHandle(OverlappedK: KOVL_HANDLE) -> HANDLE;
}
extern "C" {
    pub fn OvlK_Wait(
        OverlappedK: KOVL_HANDLE,
        TimeoutMS: INT,
        WaitFlags: KOVL_WAIT_FLAG,
        TransferredLength: PUINT,
    ) -> BOOL;
}
extern "C" {
    pub fn OvlK_WaitOldest(
        PoolHandle: KOVL_POOL_HANDLE,
        OverlappedK: *mut KOVL_HANDLE,
        TimeoutMS: INT,
        WaitFlags: KOVL_WAIT_FLAG,
        TransferredLength: PUINT,
    ) -> BOOL;
}
extern "C" {
    pub fn OvlK_WaitOrCancel(
        OverlappedK: KOVL_HANDLE,
        TimeoutMS: INT,
        TransferredLength: PUINT,
    ) -> BOOL;
}
extern "C" {
    pub fn OvlK_WaitAndRelease(
        OverlappedK: KOVL_HANDLE,
        TimeoutMS: INT,
        TransferredLength: PUINT,
    ) -> BOOL;
}
extern "C" {
    pub fn OvlK_IsComplete(OverlappedK: KOVL_HANDLE) -> BOOL;
}
extern "C" {
    pub fn OvlK_ReUse(OverlappedK: KOVL_HANDLE) -> BOOL;
}
extern "C" {
    pub fn StmK_Init(
        StreamHandle: *mut KSTM_HANDLE,
        UsbHandle: KUSB_HANDLE,
        PipeID: UCHAR,
        MaxTransferSize: INT,
        MaxPendingTransfers: INT,
        MaxPendingIO: INT,
        Callbacks: PKSTM_CALLBACK,
        Flags: KSTM_FLAG,
    ) -> BOOL;
}
extern "C" {
    pub fn StmK_Free(StreamHandle: KSTM_HANDLE) -> BOOL;
}
extern "C" {
    pub fn StmK_Start(StreamHandle: KSTM_HANDLE) -> BOOL;
}
extern "C" {
    pub fn StmK_Stop(StreamHandle: KSTM_HANDLE, TimeoutCancelMS: INT) -> BOOL;
}
extern "C" {
    pub fn StmK_Read(
        StreamHandle: KSTM_HANDLE,
        Buffer: PUCHAR,
        Offset: INT,
        Length: INT,
        TransferredLength: PUINT,
    ) -> BOOL;
}
extern "C" {
    pub fn StmK_Write(
        StreamHandle: KSTM_HANDLE,
        Buffer: PUCHAR,
        Offset: INT,
        Length: INT,
        TransferredLength: PUINT,
    ) -> BOOL;
}
extern "C" {
    pub fn IsoK_Init(IsoContext: *mut PKISO_CONTEXT, NumberOfPackets: INT, StartFrame: INT)
        -> BOOL;
}
extern "C" {
    pub fn IsoK_Free(IsoContext: PKISO_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn IsoK_SetPackets(IsoContext: PKISO_CONTEXT, PacketSize: INT) -> BOOL;
}
extern "C" {
    pub fn IsoK_SetPacket(
        IsoContext: PKISO_CONTEXT,
        PacketIndex: INT,
        IsoPacket: PKISO_PACKET,
    ) -> BOOL;
}
extern "C" {
    pub fn IsoK_GetPacket(
        IsoContext: PKISO_CONTEXT,
        PacketIndex: INT,
        IsoPacket: PKISO_PACKET,
    ) -> BOOL;
}
extern "C" {
    pub fn IsoK_EnumPackets(
        IsoContext: PKISO_CONTEXT,
        EnumPackets: ::std::option::Option<
            unsafe extern "C" fn(arg1: UINT, arg2: PKISO_PACKET, arg3: PVOID) -> BOOL,
        >,
        StartPacketIndex: INT,
        UserState: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn IsoK_ReUse(IsoContext: PKISO_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn IsochK_Init(
        IsochHandle: *mut KISOCH_HANDLE,
        InterfaceHandle: KUSB_HANDLE,
        PipeId: UCHAR,
        MaxNumberOfPackets: UINT,
        TransferBuffer: PUCHAR,
        TransferBufferSize: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn IsochK_Free(IsochHandle: KISOCH_HANDLE) -> BOOL;
}
extern "C" {
    pub fn IsochK_SetPacketOffsets(IsochHandle: KISOCH_HANDLE, PacketSize: UINT) -> BOOL;
}
extern "C" {
    pub fn IsochK_SetPacket(
        IsochHandle: KISOCH_HANDLE,
        PacketIndex: UINT,
        Offset: UINT,
        Length: UINT,
        Status: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn IsochK_GetPacket(
        IsochHandle: KISOCH_HANDLE,
        PacketIndex: UINT,
        Offset: PUINT,
        Length: PUINT,
        Status: PUINT,
    ) -> BOOL;
}
extern "C" {
    pub fn IsochK_EnumPackets(
        IsochHandle: KISOCH_HANDLE,
        EnumPackets: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: UINT,
                arg2: PUINT,
                arg3: PUINT,
                arg4: PUINT,
                arg5: PVOID,
            ) -> BOOL,
        >,
        StartPacketIndex: UINT,
        UserState: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn IsochK_CalcPacketInformation(
        IsHighSpeed: BOOL,
        PipeInformationEx: PWINUSB_PIPE_INFORMATION_EX,
        PacketInformation: PKISOCH_PACKET_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn IsochK_GetNumberOfPackets(IsochHandle: KISOCH_HANDLE, NumberOfPackets: PUINT) -> BOOL;
}
extern "C" {
    pub fn IsochK_SetNumberOfPackets(IsochHandle: KISOCH_HANDLE, NumberOfPackets: UINT) -> BOOL;
}
extern "C" {
    pub fn LUsb0_ControlTransfer(
        InterfaceHandle: KUSB_HANDLE,
        SetupPacket: WINUSB_SETUP_PACKET,
        Buffer: PUCHAR,
        BufferLength: UINT,
        LengthTransferred: PUINT,
        Overlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn LUsb0_SetConfiguration(InterfaceHandle: KUSB_HANDLE, ConfigurationNumber: UCHAR)
        -> BOOL;
}
